<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hell&copter - Boss Strike</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #0d0d0d;
            --nes-red: #e74c3c;
            --nes-blue: #3498db;
            --nes-yellow: #f1c40f;
            --nes-white: #ecf0f1;
            --nes-dark: #212529;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            color: var(--nes-white);
            image-rendering: pixelated;
        }

        #game-container {
            position: relative;
            border: 8px solid #333;
            background-color: #000;
            outline: 4px solid #111;
            box-shadow: 0 0 0 12px #222, 0 20px 50px rgba(0,0,0,0.9);
        }

        canvas {
            display: block;
            background: #1e392a; 
            image-rendering: pixelated; 
        }

        #ui-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 45px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            text-shadow: 2px 2px 0px #000;
            z-index: 20;
        }

        #progress-container {
            position: absolute;
            right: 10px;
            top: 50px;
            bottom: 50px;
            width: 12px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #555;
            z-index: 20;
        }

        #progress-bar {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 0%;
            background: var(--nes-yellow);
            transition: height 0.3s;
            box-shadow: 0 0 10px var(--nes-yellow);
        }

        #start-screen, #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 30;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 { 
            font-size: 24px; 
            margin: 0 0 20px 0; 
            color: var(--nes-red); 
            text-shadow: 4px 4px 0px #4a0000;
            letter-spacing: 2px;
        }

        .btn {
            background: var(--nes-white);
            border: none;
            border-bottom: 6px solid #bdc3c7;
            color: var(--nes-dark);
            padding: 15px 25px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            margin-top: 20px;
        }

        .btn:hover { background: var(--nes-yellow); }
        .highlight { color: var(--nes-yellow); }

        #over-canvas {
            width: 160px;
            height: 180px;
            background: transparent;
            margin-bottom: 10px;
        }

        @media (max-width: 600px) {
            #game-container { width: 95vw; height: 80vh; border-width: 4px; }
            canvas { width: 100%; height: 100%; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="ui-overlay">
            <div>SCORE:<span id="score-val" class="highlight">0000</span></div>
            <div>HEAVY:<span id="weapon-type" class="highlight">READY</span></div>
            <div>HP:<span id="hp-val">100</span></div>
        </div>

        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="start-screen">
            <h1>HELL&COPTER</h1>
            <p class="highlight">SURVIVE 60S TO REACH BOSS</p>
            <button class="btn" onclick="startGame()">START MISSION</button>
            <div style="margin-top:20px; font-size: 8px; color: #777;">
                [ARROWS] MOVE | [SPACE] ROCKETS | [CTRL] HEAVY
            </div>
        </div>

        <div id="game-over" style="display: none;">
            <canvas id="over-canvas"></canvas>
            <h1 id="over-title">MISSION FAILED</h1>
            <p>FINAL SCORE: <span id="final-score" class="highlight">0</span></p>
            <button class="btn" onclick="startGame()">REDEPLOY</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const overCanvas = document.getElementById('over-canvas');
    const overCtx = overCanvas.getContext('2d');
    const scoreVal = document.getElementById('score-val');
    const hpVal = document.getElementById('hp-val');
    const progressBar = document.getElementById('progress-bar');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over');
    const finalScoreTxt = document.getElementById('final-score');
    const weaponTypeTxt = document.getElementById('weapon-type');

    const PIXEL_SIZE = 4;
    const MISSION_DURATION = 60 * 60; 
    let gameActive = false;
    let score = 0;
    let frame = 0;
    let missionTime = 0;
    let animationFrameId = null;
    let overFrameId = null;

    const player = {
        x: 0, y: 0, w: 60, h: 52, 
        speed: 4.5, hp: 100, 
        rotation: 0,
        rockets: [],
        lastShot: 0,
        shotDelay: 10,
        lastAltShot: 0,
        altShotDelay: 70,
        destroyed: false
    };

    let enemies = [];
    let enemyRockets = [];
    let particles = [];
    let keys = {};
    let landscape = []; 
    let speedLines = [];
    let boss = null;
    let flagProgress = 0;

    const SHADOW_OFFSET = 16;
    const SHADOW_COLOR = 'rgba(0, 0, 0, 0.4)';

    function resize() {
        canvas.width = 400;
        canvas.height = 600;
        overCanvas.width = 160;
        overCanvas.height = 180;
        player.x = canvas.width / 2 - player.w / 2;
        player.y = canvas.height - 140;
    }

    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if(['ControlLeft', 'ControlRight', 'ArrowUp', 'ArrowDown', 'Space', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    function generatePixelBlob(type) {
        const blocks = [];
        let baseSize, iterations;
        if (type === 'lake') { baseSize = 8; iterations = 25; }
        else { baseSize = 6; iterations = 18; }
        let cx = 0, cy = 0;
        for(let i = 0; i < iterations; i++) {
            let w = Math.floor(Math.random() * baseSize) + 2;
            let h = Math.floor(Math.random() * baseSize) + 2;
            blocks.push({ dx: cx, dy: cy, dw: w * PIXEL_SIZE, dh: h * PIXEL_SIZE });
            cx += (Math.random() - 0.5) * baseSize * PIXEL_SIZE;
            cy += (Math.random() - 0.5) * baseSize * PIXEL_SIZE;
        }
        return blocks;
    }

    function spawnLandscape(yPos = -200) {
        const type = Math.random() > 0.15 ? 'forest' : 'lake';
        let color, altColor;
        if (type === 'lake') { color = '#1e5d7a'; altColor = '#3498db'; }
        else { color = '#143b23'; altColor = '#1b4d2e'; }
        landscape.push({
            x: Math.random() * canvas.width,
            y: yPos,
            blocks: generatePixelBlob(type),
            color: color,
            altColor: altColor,
            speed: 2,
            type: type
        });
    }

    function initGame() {
        score = 0;
        frame = 0;
        missionTime = 0;
        player.hp = 100;
        player.destroyed = false;
        player.rockets = [];
        player.lastShot = 0;
        player.lastAltShot = 0;
        player.x = canvas.width / 2 - player.w / 2;
        player.y = canvas.height - 140;
        player.rotation = 0;
        enemies = [];
        enemyRockets = [];
        particles = [];
        landscape = [];
        speedLines = [];
        boss = null;
        flagProgress = 0;
        scoreVal.innerText = "0000";
        hpVal.innerText = "100";
        progressBar.style.height = "0%";
        for(let i=0; i<35; i++) spawnLandscape(Math.random() * (canvas.height + 400) - 200);
        for(let i=0; i<15; i++) speedLines.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, len: 10 + Math.random()*20});
    }

    function startGame() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        if (overFrameId) cancelAnimationFrame(overFrameId);
        resize();
        initGame();
        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        gameActive = true;
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function createPixelCollapse(x, y, count = 150) {
        const colors = ['#2e86c1', '#3498db', '#ecf0f1', '#e74c3c', '#f1c40f', '#000'];
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 18,
                vy: (Math.random() - 0.5) * 18,
                life: 40 + Math.random() * 40,
                color: colors[Math.floor(Math.random() * colors.length)],
                size: PIXEL_SIZE + (Math.random() > 0.8 ? PIXEL_SIZE : 0),
                gravity: 0.1
            });
        }
    }

    function drawEliteHeli(x, y, color, isShadow = false, isPlayer = true, tiltAngle = 0, scale = 1) {
        if (isPlayer && player.destroyed) return;
        const ox = Math.round(x / PIXEL_SIZE) * PIXEL_SIZE;
        const oy = Math.round(y / PIXEL_SIZE) * PIXEL_SIZE;
        const main = isShadow ? SHADOW_COLOR : color;
        const dark = isShadow ? SHADOW_COLOR : '#1a5276';
        const glass = isShadow ? SHADOW_COLOR : '#dff9fb';
        
        ctx.save();
        ctx.translate(ox + (20 * scale), oy + (26 * scale));
        ctx.rotate(tiltAngle);
        ctx.scale(scale, scale);
        ctx.translate(-(ox + 20), -(oy + 26));
        
        // Tail
        ctx.fillStyle = main;
        ctx.fillRect(ox + 16, oy + 36, 8, 12);
        ctx.fillStyle = dark;
        ctx.fillRect(ox + 12, oy + 48, 16, 4);
        
        // Body
        ctx.fillStyle = main;
        ctx.fillRect(ox + 8, oy + 12, 24, 20);
        ctx.fillStyle = dark;
        ctx.fillRect(ox + 12, oy + 4, 16, 8);
        
        // Windows
        ctx.fillStyle = glass;
        ctx.fillRect(ox + 16, oy + 8, 8, 8);
        
        // Rotor
        ctx.save();
        ctx.translate(ox + 20, oy + 20);
        ctx.rotate(frame * 0.4);
        ctx.fillStyle = isShadow ? SHADOW_COLOR : 'rgba(255, 255, 255, 0.4)';
        ctx.fillRect(-30, -2, 60, 4);
        ctx.fillRect(-2, -30, 4, 60);
        ctx.restore();
        ctx.restore();
    }

    function drawDetailedTank(en, isShadow = false) {
        const ox = Math.round(en.x / PIXEL_SIZE) * PIXEL_SIZE;
        const oy = Math.round(en.y / PIXEL_SIZE) * PIXEL_SIZE;
        const color = isShadow ? SHADOW_COLOR : '#4b5320';
        const treadColor = isShadow ? SHADOW_COLOR : '#2a2e12';
        const detailColor = isShadow ? SHADOW_COLOR : '#5c633a';

        ctx.save();
        ctx.translate(ox + 20, oy + 20);
        ctx.rotate(en.angle || 0);
        ctx.translate(-20, -20);

        // Treads
        ctx.fillStyle = treadColor;
        ctx.fillRect(0, 4, 8, 32);
        ctx.fillRect(32, 4, 8, 32);
        
        // Hull
        ctx.fillStyle = color;
        ctx.fillRect(6, 6, 28, 28);
        ctx.fillStyle = detailColor;
        ctx.fillRect(8, 8, 24, 2);
        ctx.fillRect(8, 30, 24, 2);
        
        // Turret
        ctx.fillStyle = treadColor;
        ctx.fillRect(12, 12, 16, 16);
        ctx.fillStyle = detailColor;
        ctx.fillRect(14, 14, 12, 12);
        
        // Barrel
        ctx.fillStyle = treadColor;
        ctx.fillRect(18, 26, 4, 14);
        
        ctx.restore();
    }

    function drawBoss(b) {
        const ox = Math.round(b.x / PIXEL_SIZE) * PIXEL_SIZE;
        const oy = Math.round(b.y / PIXEL_SIZE) * PIXEL_SIZE;
        ctx.save();
        ctx.fillStyle = SHADOW_COLOR;
        ctx.fillRect(ox + 20, oy + 20, 160, 120);
        ctx.fillStyle = '#1a5276';
        ctx.fillRect(ox + 20, oy + 20, 120, 80); 
        ctx.fillStyle = '#154360';
        ctx.fillRect(ox, oy + 40, 160, 30); 
        ctx.fillStyle = '#212f3c';
        ctx.fillRect(ox + 10, oy + 30, 12, 12);
        ctx.fillRect(ox + 138, oy + 30, 12, 12);
        ctx.fillStyle = '#1a5276';
        ctx.fillRect(ox + 60, oy - 30, 40, 50);
        ctx.fillStyle = '#154360';
        ctx.fillRect(ox + 30, oy - 45, 100, 15);
        ctx.fillStyle = '#dff9fb';
        ctx.globalAlpha = 0.8;
        ctx.fillRect(ox + 50, oy + 60, 60, 25);
        ctx.globalAlpha = 1.0;
        for(let i=0; i<2; i++) {
            ctx.save();
            ctx.translate(ox + 40 + (i*80), oy + 40);
            ctx.rotate(frame * (i === 0 ? 0.6 : -0.6));
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(-90, -6, 180, 12);
            ctx.fillRect(-6, -90, 12, 180);
            ctx.restore();
        }
        const hpPercent = b.hp / b.maxHp;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(ox, oy - 70, 160, 12);
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(ox, oy - 70, 160 * hpPercent, 12);
        ctx.restore();
    }

    function flagLoop() {
        if (gameActive) return;
        overFrameId = requestAnimationFrame(flagLoop);
        overCtx.clearRect(0, 0, overCanvas.width, overCanvas.height);
        
        if (flagProgress < 0.6) flagProgress += 0.008;
        
        const time = Date.now() * 0.006;
        const poleX = 40;
        const poleY = overCanvas.height - 20;
        const poleHeight = 140;
        const flagWidth = 85;
        const flagHeight = 48;
        
        overCtx.fillStyle = '#555';
        overCtx.fillRect(poleX - 2, poleY - poleHeight, 4, poleHeight);
        overCtx.fillStyle = '#f1c40f';
        overCtx.fillRect(poleX - 4, poleY - poleHeight, 8, 4);
        
        if (flagProgress > 0.1) {
            const currentPoleTop = poleY - (poleHeight * flagProgress);
            const unfurl = Math.min(1, (flagProgress - 0.1) * 2.5);
            const startY = currentPoleTop + 8;
            const segmentCount = 30;
            const segmentWidth = (flagWidth / segmentCount) * unfurl;

            for (let i = 0; i < segmentCount; i++) {
                const x = poleX + 2 + (i * segmentWidth);
                const waveIntensity = i / segmentCount;
                const waveMain = Math.sin(time * 3 - i * 0.4) * 8 * waveIntensity;
                const yOffset = waveMain;
                const xOffset = Math.sin(time * 4 + i * 0.6) * 3 * waveIntensity;

                const isCanton = (i < segmentCount * 0.4) && unfurl > 0.1;
                const stripeHeight = flagHeight / 13;
                
                for (let s = 0; s < 13; s++) {
                    overCtx.fillStyle = (s % 2 === 0) ? '#B22234' : '#FFFFFF';
                    if (!(isCanton && s < 7)) {
                        overCtx.fillRect(x + xOffset, startY + yOffset + (s * stripeHeight), segmentWidth + 1, stripeHeight + 0.5);
                    }
                }

                if (isCanton) {
                    overCtx.fillStyle = '#3C3B6E';
                    overCtx.fillRect(x + xOffset, startY + yOffset, segmentWidth + 1, stripeHeight * 7);
                    if (Math.floor(time * 2) % 2 === 0) {
                        overCtx.fillStyle = '#FFFFFF';
                        if (i % 4 === 0) overCtx.fillRect(x + xOffset + 2, startY + yOffset + 4, 2, 2);
                    }
                }

                const slope = Math.cos(time * 3 - i * 0.4);
                overCtx.fillStyle = `rgba(0,0,0,${Math.max(0, slope * 0.3)})`;
                overCtx.fillRect(x + xOffset, startY + yOffset, segmentWidth + 1, flagHeight);
            }
        }
    }

    function gameLoop() {
        if(!gameActive) return;
        frame++;

        if (missionTime < MISSION_DURATION && !boss) missionTime++;
        const progress = Math.min(100, (missionTime / MISSION_DURATION) * 100);
        progressBar.style.height = progress + "%";

        ctx.fillStyle = '#0f291b'; ctx.fillRect(0,0,canvas.width, canvas.height);
        landscape.forEach((item, i) => {
            item.y += item.speed;
            item.blocks.forEach((block, bi) => {
                const bx = item.x + block.dx; const by = item.y + block.dy;
                ctx.fillStyle = item.color; ctx.fillRect(bx, by, block.dw, block.dh);
                if (item.type === 'lake' && bi % 3 === 0) { ctx.fillStyle = item.altColor; ctx.fillRect(bx, by, block.dw, PIXEL_SIZE); }
                else if (item.type === 'forest' && bi % 2 === 0) { ctx.fillStyle = item.altColor; ctx.fillRect(bx + PIXEL_SIZE, by + PIXEL_SIZE, block.dw - PIXEL_SIZE*2, block.dh - PIXEL_SIZE*2); }
            });
            if(item.y > canvas.height + 400) { landscape.splice(i, 1); spawnLandscape(); }
        });

        ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
        speedLines.forEach(line => {
            line.y += 15; ctx.beginPath(); ctx.moveTo(line.x, line.y); ctx.lineTo(line.x, line.y + line.len); ctx.stroke();
            if (line.y > canvas.height) line.y = -50;
        });

        if (!player.destroyed) {
            let targetRotation = 0;
            if (keys['ArrowLeft']) { player.x -= player.speed; targetRotation = -0.25; }
            if (keys['ArrowRight']) { player.x += player.speed; targetRotation = 0.25; }
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;
            player.rotation += (targetRotation - player.rotation) * 0.15;
            player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
            player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));

            if (keys['Space'] && frame - player.lastShot > player.shotDelay) {
                player.rockets.push({x: player.x + 10, y: player.y, vy: -12, type: 'light'});
                player.rockets.push({x: player.x + 40, y: player.y, vy: -12, type: 'light'});
                player.lastShot = frame;
            }
            if ((keys['ControlLeft'] || keys['ControlRight']) && frame - player.lastAltShot > player.altShotDelay) {
                player.rockets.push({x: player.x - 5, y: player.y + 10, vy: -15, type: 'heavy'});
                player.rockets.push({x: player.x + player.w - 10, y: player.y + 10, vy: -15, type: 'heavy'});
                player.lastAltShot = frame;
            }
        }

        if (missionTime >= MISSION_DURATION && !boss) {
            boss = { x: canvas.width / 2 - 80, y: -250, w: 160, h: 100, hp: 8000, maxHp: 8000, speed: 1.2, lastFire: 0, targetX: canvas.width / 2 - 80 };
        }
        if (boss) {
            if (boss.y < 80) boss.y += boss.speed;
            else {
                if (frame % 80 === 0) boss.targetX = Math.random() * (canvas.width - boss.w);
                boss.x += (boss.targetX - boss.x) * 0.02;
                if (frame - boss.lastFire > 35) {
                    enemyRockets.push({x: boss.x + 10, y: boss.y + 70, vy: 5, vx: -1});
                    enemyRockets.push({x: boss.x + 150, y: boss.y + 70, vy: 5, vx: 1});
                    enemyRockets.push({x: boss.x + 80, y: boss.y + 90, vy: 7, vx: 0});
                    boss.lastFire = frame;
                }
            }
            drawBoss(boss);
        }

        if (!boss && !player.destroyed && frame % 45 === 0) {
            const isTank = Math.random() > 0.4;
            enemies.push({ 
                x: Math.random() * (canvas.width - 40), 
                y: -50, 
                w: 40, 
                h: 40, 
                // TANK speed matches landscape speed to appear static
                speed: isTank ? 2 : 3.5, 
                type: isTank ? 'TANK' : 'HELI',
                angle: 0
            });
        }

        player.rockets.forEach((r, i) => {
            r.y += r.vy;
            if (r.type === 'heavy') {
                ctx.fillStyle = '#555'; ctx.fillRect(r.x, r.y, 16, 32);
                ctx.fillStyle = '#f1c40f'; ctx.fillRect(r.x + 4, r.y - 4, 8, 8);
                const fireY = r.y + 32; ctx.fillStyle = frame % 2 === 0 ? '#ff4d4d' : '#ff9f43'; ctx.fillRect(r.x + 4, fireY, 8, 12 + Math.random() * 8);
            } else { ctx.fillStyle = '#ff9f43'; ctx.fillRect(r.x, r.y, 4, 12); }
            if(r.y < -100) { player.rockets.splice(i, 1); return; }
            if (boss && r.x > boss.x && r.x < boss.x + boss.w && r.y < boss.y + boss.h && r.y > boss.y) {
                boss.hp -= (r.type === 'heavy' ? 450 : 35);
                particles.push({x: r.x, y: r.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 15, color: '#fff'});
                player.rockets.splice(i, 1);
                if (boss.hp <= 0) { createPixelCollapse(boss.x + boss.w/2, boss.y + boss.h/2, 500); score += 20000; boss = null; missionTime = 0; }
                return;
            }
        });

        enemyRockets.forEach((r, i) => {
            r.y += r.vy; if (r.vx) r.x += r.vx;
            ctx.fillStyle = '#e74c3c'; ctx.fillRect(r.x, r.y, 6, 12);
            if (!player.destroyed && r.x > player.x && r.x < player.x + player.w && r.y > player.y && r.y < player.y + player.h) {
                player.hp -= 20; enemyRockets.splice(i, 1);
                if (player.hp <= 0) { triggerPlayerDeath(); }
            }
            if(r.y > canvas.height) enemyRockets.splice(i, 1);
        });

        enemies.forEach((en, i) => {
            en.y += en.speed;

            if (en.type === 'HELI') drawEliteHeli(en.x, en.y, '#c0392b', false, false, Math.PI); 
            else drawDetailedTank(en);

            if (!player.destroyed && Math.abs(player.x - en.x) < 35 && Math.abs(player.y - en.y) < 35) {
                triggerPlayerDeath();
            }

            player.rockets.forEach((r, ri) => {
                const rw = r.type === 'heavy' ? 16 : 4; const rh = r.type === 'heavy' ? 32 : 12;
                if(r.x < en.x + en.w && r.x + rw > en.x && r.y < en.y + en.h && r.y + rh > en.y) {
                    if ((en.type === 'HELI') || (en.type === 'TANK' && r.type === 'heavy')) { 
                        enemies.splice(i, 1); player.rockets.splice(ri, 1); 
                        score += en.type === 'TANK' ? 250 : 100; 
                        createPixelCollapse(en.x + en.w/2, en.y + en.h/2, 40); 
                    } else { 
                        player.rockets.splice(ri, 1); 
                        particles.push({x: r.x, y: r.y, vx: 2, vy: 2, life: 5, color: '#777'}); 
                    }
                }
            });
            if(en.y > canvas.height + 100) enemies.splice(i, 1);
        });

        particles.forEach((p, i) => {
            p.vx += (p.gravity || 0); p.x += p.vx; p.y += p.vy; p.life--;
            ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size || 4, p.size || 4);
            if(p.life <= 0) particles.splice(i, 1);
        });

        if (!player.destroyed) {
            drawEliteHeli(player.x + SHADOW_OFFSET, player.y + SHADOW_OFFSET, '#000', true, true, player.rotation);
            drawEliteHeli(player.x, player.y, '#2e86c1', false, true, player.rotation);
        }

        scoreVal.innerText = score.toString().padStart(4, '0');
        hpVal.innerText = Math.max(0, player.hp);
        weaponTypeTxt.innerText = (frame - player.lastAltShot > player.altShotDelay) ? "READY" : "RELOADING";
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function triggerPlayerDeath() {
        if (player.destroyed) return;
        player.destroyed = true;
        player.hp = 0;
        createPixelCollapse(player.x + player.w/2, player.y + player.h/2, 400);
        setTimeout(() => createPixelCollapse(player.x + player.w/2, player.y + player.h/2, 200), 200);
        setTimeout(() => {
            gameActive = false;
            gameOverScreen.style.display = 'flex';
            finalScoreTxt.innerText = score;
            flagProgress = 0;
            flagLoop();
        }, 1500); 
    }

    resize();
</script>
</body>
</html>
